<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Flipbook Viewer</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <style>
    :root{
      --bg:#f7f3ea;
      --ink:#2b2b2b;
      --brand:#254B4F;
      --brand-ink:#F5E9D8;
      --panel:#ffffff;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Apple SD Gothic Neo,Malgun Gothic,Noto Sans KR,sans-serif}
    .app{display:grid;grid-template-rows:auto 1fr; height:100%;}
    header{display:flex;align-items:center;gap:.75rem;padding:.5rem .75rem;background:var(--panel);border-bottom:1px solid #e7e2d7;position:sticky;top:0;z-index:5}
    header .logo{display:flex;align-items:center;gap:.5rem}
    header img.logo-img{height:28px;width:auto;object-fit:contain}
    header .brand{font-weight:700}
    .toolbar{display:flex;align-items:center;gap:.5rem;flex-wrap:wrap;margin-left:auto}
    .btn{border:1px solid #ddd;background:#fff;padding:.45rem .65rem;border-radius:.5rem;cursor:pointer}
    .btn.brand{background:var(--brand);color:var(--brand-ink);border-color:transparent}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .btn-toggle{display:inline-flex;align-items:center;gap:.35rem}
    .sep{width:1px;height:28px;background:#e4ded2;margin:0 .25rem}
    .viewer-wrap{display:grid;grid-template-columns: 260px 1fr; gap:0; height:100%; min-height:0}
    .viewer-wrap.toc-hidden{grid-template-columns:0 1fr}
    nav#toc{overflow:auto;border-right:1px solid #eadfcd;background:#fcfbf7}
    nav#toc h3{margin:.75rem 1rem .25rem;font-size:.95rem;color:#6e5f46}
    nav#toc ul{list-style:none;margin:0;padding:.25rem .5rem .75rem}
    nav#toc li{padding:.25rem .5rem}
    nav#toc a{color:var(--ink);text-decoration:none;font-size:.9rem}
    nav#toc a:hover{color:var(--brand)}
    .stage{position:relative;overflow:auto;background:linear-gradient(45deg, rgba(0,0,0,.02), rgba(0,0,0,.06)); display:grid; place-items:center}
    #flipbook{width:min(92vw,1100px);height:min(80vh, 880px);}
    .page-preloader{position:absolute;inset:0;display:grid;place-items:center;color:#6b6b6b;font-size:.95rem}
    .stf__block{box-shadow:0 10px 40px rgba(0,0,0,.10)}
    .hint{font-size:.8rem;color:#6f6f6f;margin-left:.5rem}
    .fullscreen{background:var(--bg)}
    @media (max-width:900px){ .viewer-wrap{grid-template-columns: 0 1fr} }
  </style>
  <!-- PDF.js (core + worker) -->
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@4.8.69/build/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.8.69/build/pdf.worker.min.js";</script>
  <!-- StPageFlip (3D turn effect) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/stpageflip@2.0.7/dist/css/stpageflip.min.css" />
  <script src="https://cdn.jsdelivr.net/npm/stpageflip@2.0.7/dist/js/stpageflip.min.js"></script>
</head>
<body>
<div class="app">
  <header>
    <div class="logo">
      <img class="logo-img" src="./assets/logo.png" alt="logo" onerror="this.style.display='none'">
      <div class="brand">Flipbook</div>
    </div>
    <div class="toolbar">
      <label>파일:
        <select id="fileSelect" class="btn"></select>
      </label>
      <button id="prevBtn" class="btn" title="이전 페이지">◀</button>
      <button id="nextBtn" class="btn" title="다음 페이지">▶</button>
      <span id="pageLabel" class="hint">- / -</span>
      <span class="sep"></span>
      <button id="zoomOut" class="btn" title="축소">－</button>
      <button id="zoomIn" class="btn" title="확대">＋</button>
      <button id="fitBtn" class="btn" title="화면맞춤">맞춤</button>
      <span class="sep"></span>
      <button id="fsBtn" class="btn brand" title="전체화면">⛶</button>
      <label class="btn btn-toggle"><input type="checkbox" id="tocToggle" checked> 목차</label>
      <label class="btn btn-toggle"><input type="checkbox" id="disableDl"> 다운로드 비활성화</label>
    </div>
  </header>

  <div class="viewer-wrap" id="viewerWrap">
    <nav id="toc"><h3>목차</h3><ul id="tocList"></ul></nav>
    <main class="stage" id="stage">
      <div id="flipbook"></div>
      <div class="page-preloader" id="preloader" hidden>페이지 준비 중…</div>
    </main>
  </div>
</div>

<script>
const state = { pdf:null, total:0, scale:1.0, minScale:0.6, maxScale:2.5, pages:[], flip:null, current:1, manifest:[], disableDownload:false };
const el = sel => document.querySelector(sel); const $ = id => document.getElementById(id);
const fileSelect = $("fileSelect"); const pageLabel = $("pageLabel"); const preloader = $("preloader"); const tocList = $("tocList"); const tocToggle = $("tocToggle"); const viewerWrap = $("viewerWrap");

async function fetchJSON(url){ const res = await fetch(url); if(!res.ok) throw new Error("JSON 읽기 실패: "+res.status); return await res.json(); }
function getQuery(name){ const u=new URL(location.href); return u.searchParams.get(name); }

async function initFiles(){
  const q = getQuery('file');
  try{ state.manifest = await fetchJSON('./ebooks/manifest.json'); }catch(e){ state.manifest = []; }
  fileSelect.innerHTML = ''; const ph = document.createElement('option'); ph.textContent='파일을 선택하세요'; ph.value=''; fileSelect.appendChild(ph);
  state.manifest.forEach(item=>{ const opt=document.createElement('option'); opt.value=item.url; opt.textContent=item.title || item.url.split('/').pop(); fileSelect.appendChild(opt); });
  if(q){ await loadPDF(q); } else if(state.manifest[0]){ fileSelect.value=state.manifest[0].url; await loadPDF(state.manifest[0].url); }
}
fileSelect.addEventListener('change', async e=>{ if(!e.target.value) return; await loadPDF(e.target.value); });

async function loadPDF(url){
  cleanupFlip(); preloader.hidden=false; pageLabel.textContent='- / -'; tocList.innerHTML='';
  const task = pdfjsLib.getDocument({url}); state.pdf = await task.promise; state.total = state.pdf.numPages;
  state.pages = Array.from({length: state.total}, ()=>({img:null, rendering:false})); pageLabel.textContent = `1 / ${state.total}`;
  try{ const outline = await state.pdf.getOutline(); if(outline && outline.length){ buildTOC(outline); tocToggle.checked=true; viewerWrap.classList.remove('toc-hidden'); } else { tocToggle.checked=false; viewerWrap.classList.add('toc-hidden'); } }catch{}
  initFlip();
  await ensureRendered(1); if(state.total>=2) await ensureRendered(2); feedFlipInitial(); preloader.hidden=true;
}

function buildTOC(outline){
  tocList.innerHTML=''; const root=document.createElement('ul'); tocList.appendChild(root);
  const walk=(items,ul)=>{ items.forEach(async item=>{ const li=document.createElement('li'); const a=document.createElement('a'); a.textContent=item.title||'제목 없음'; a.href='#'; a.addEventListener('click',async e=>{ e.preventDefault(); const dest=await state.pdf.getDestination(item.dest); const pageIndex = dest?.[0]?.num ? dest[0].num : (dest?.[0]?.pageNumber || 1); goTo(pageIndex); }); li.appendChild(a); ul.appendChild(li); if(item.items?.length){ const child=document.createElement('ul'); li.appendChild(child); walk(item.items,child);} }); };
  walk(outline, root);
}
tocToggle.addEventListener('change',()=> viewerWrap.classList.toggle('toc-hidden', !tocToggle.checked));

function initFlip(){
  const container = document.getElementById('flipbook'); container.innerHTML='';
  state.flip = new St.PageFlip(container, { width:520, height:720, size:'stretch', maxShadowOpacity:0.2, showCover:false, useMouseEvents:true, flippingTime:600, drawShadow:true, autoSize:true });
  state.flip.on('flip', async (e)=>{ state.current = e.data; pageLabel.textContent = `${state.current} / ${state.total}`;
    const around=[state.current-2,state.current-1,state.current+1,state.current+2].filter(n=>n>=1 && n<=state.total);
    for(const p of around){ await ensureRendered(p); }
  });
}

async function ensureRendered(pageNumber){
  const slot = state.pages[pageNumber-1]; if(slot.img || slot.rendering) return; slot.rendering=true;
  const page = await state.pdf.getPage(pageNumber); const viewport = page.getViewport({scale:1});
  const container=document.getElementById('flipbook'); const basis=Math.min((container.clientWidth/2)/viewport.width, container.clientHeight/viewport.height);
  const scale = Math.max(1, basis) * state.scale; const v2 = page.getViewport({scale});
  const canvas=document.createElement('canvas'); const ctx=canvas.getContext('2d',{alpha:false}); canvas.width=Math.floor(v2.width); canvas.height=Math.floor(v2.height);
  await page.render({canvasContext:ctx, viewport:v2, intent:'display'}).promise;

  const annotations = await page.getAnnotations(); const imgURL = canvas.toDataURL('image/jpeg', 0.92);
  const wrapper=document.createElement('div'); Object.assign(wrapper.style,{position:'relative', width:v2.width+'px', height:v2.height+'px'});
  const img=new Image(); img.src=imgURL; img.draggable=false; Object.assign(img.style,{width:'100%',height:'100%',userSelect:'none'}); wrapper.appendChild(img);
  const linkLayer=document.createElement('div'); Object.assign(linkLayer.style,{position:'absolute', inset:'0', pointerEvents: state.disableDownload?'none':'auto'}); wrapper.appendChild(linkLayer);
  const transform = pdfjsLib.Util.transform; const view = page.view; const viewportTransform = v2.transform; const outputScale=1;
  annotations.filter(a=>a.subtype==='Link' && a.rect).forEach(a=>{
    let rect = pdfjsLib.Util.normalizeRect(a.rect);
    let m = transform(viewportTransform, [1,0,0,-1,0,v2.height]);
    let x1=rect[0],y1=rect[1],x2=rect[2],y2=rect[3];
    let p1 = pdfjsLib.Util.applyTransform([x1,y1], m); let p2 = pdfjsLib.Util.applyTransform([x2,y2], m);
    const left=Math.min(p1[0],p2[0])*outputScale, top=Math.min(p1[1],p2[1])*outputScale, width=Math.abs(p1[0]-p2[0])*outputScale, height=Math.abs(p1[1]-p2[1])*outputScale;
    const link=document.createElement('a'); link.href=a.url||'#'; link.target='_blank'; link.rel='noopener'; Object.assign(link.style,{position:'absolute',left:left+'px',top:top+'px',width:width+'px',height:height+'px',display:'block',background:'rgba(0,0,0,0)'}); linkLayer.appendChild(link);
  });
  slot.img = wrapper; slot.rendering=false;
}

function feedFlipInitial(){
  const nodes=[];
  for(let i=1;i<=Math.min(4,state.total);i++){ const node=document.createElement('div'); node.className='page'; node.appendChild(state.pages[i-1].img); nodes.push(node); }
  state.flip.loadFromHTML(nodes);
}

function cleanupFlip(){ if(state.flip){ try{state.flip.destroy();}catch(e){} state.flip=null; } }
function goTo(n){ if(!state.flip) return; n=Math.max(1, Math.min(state.total, n)); state.flip.flip(n); }

$("prevBtn").onclick = ()=> goTo(state.current-1);
$("nextBtn").onclick = ()=> goTo(state.current+1);
$("zoomIn").onclick = async ()=>{ state.scale=Math.min(2.5, state.scale+0.15); await rerenderAround(); };
$("zoomOut").onclick = async ()=>{ state.scale=Math.max(0.6, state.scale-0.15); await rerenderAround(); };
$("fitBtn").onclick = async ()=>{ state.scale=1.0; await rerenderAround(true); };

async function rerenderAround(){ preloader.hidden=false;
  const pages=[state.current-1,state.current,state.current+1].filter(n=>n>=1&&n<=state.total);
  for(const p of pages){ state.pages[p-1].img=null; await ensureRendered(p); }
  cleanupFlip(); initFlip(); feedFlipInitial(); preloader.hidden=true;
}

$("fsBtn").onclick = ()=>{ const el = document.documentElement; if(!document.fullscreenElement){ el.requestFullscreen?.(); document.body.classList.add('fullscreen'); } else { document.exitFullscreen?.(); document.body.classList.remove('fullscreen'); } };
$("disableDl").addEventListener('change',(e)=>{ state.disableDownload=e.target.checked; document.addEventListener('contextmenu', blockCtx, {capture:true}); if(!state.disableDownload){ document.removeEventListener('contextmenu', blockCtx, {capture:true}); } });
function blockCtx(ev){ if(state.disableDownload) ev.preventDefault(); }

initFiles();
</script>
</body>
</html>
